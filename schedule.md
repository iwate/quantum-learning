https://github.com/microsoft/qio-samples//blob/main/samples/job-shop-scheduling/job-shop-sample.py

## Shchedule Problemを考える

解きたい問題、オペレーションを実行するスケジュールを解く
オペレーションには作業時間と実行できるマシンが決まっており、それぞれのオペレーションを1回だけ実行するときに最も効率のいいスケジュールを考えたい
最も効率が良いとは、総作業時間が一番短いものを差す。

総実行時間のリミットをTとして21時簡単位にする。

$$T = 21$$

実行するオペレーションは10個あり、それぞれ以下の時間だけ作業時間がかかる

$$
	(t_{op_0}, t_{op_1}, ..., t_{op_9}) = (2,1,3,2,2,3,1,2,3,2)
$$



オペレーションは単体で実行されることはなく、オペレーションを複数個実行順に並べられたジョブにまとめられる。今実行したいのは以下の3つである。


$$
\begin{aligned}
job_0 &= (op_0, op_1, op_2) \\
job_1 &= (op_3, op_4, op_5) \\
job_2 &= (op_6, op_7, op_8, op_9)
\end{aligned}
$$

オペレーションはそれぞれ以下のマシンで実行する

$$
\begin{aligned}
	machine_0 &= (op_0, op_1, op_3, op_4, op_6, op_7) \\
	machine_1 &= (op_2, op_5, op_8) \\
	machine_2 &= (op_9)
\end{aligned}
$$

これらの条件をCost関数に落とし込む必要がある。

これだとちょっと大きすぎる条件を小さくして考えてみる

$$
\begin{aligned}
T &= 5 \\
job_0 &= (op_0) \\
job_1 &= (op_1, op_2) \\
machine_0 &= (op_0, op_1) \\
machine_1 &= (op_2) \\
(t_{op_0}, t_{op_1}, t_{op_2}) &= (2,1,3) 
\end{aligned}
$$


### precedence_constraint
優先順位制約

優先順位のペナルティはコードを読み解くとこんな式

$$
\sum_{ops \leftarrow jobs} \sum_{i=0}^{(len(ops)-1)-1} \sum_{t=0}^{T-1} \sum_{s=0}^{min(t+t_{ops_i},T)-1}wx_{ops_iT+t}x_{ops_{i+1}T+s}
$$

sがめんどそうなので先に列挙しておく

$$
\begin{aligned}
s(i)(t) &= range(0, min(t + t_{ops_i}, T)) \\
s_{job_0}(0)(0) &= range(0, min(0 + t_{ops_0}, T)) \\
	&= range(0, min(0 + t_{op_0}, T)) \\
	&= range(0, min(0 + 2, T)) \\
	&= range(0, 2) \\
	&= (0, 1) \\
s_{job_0}(0)(1) &= (0, 1, 2) \\
s_{job_0}(0)(2) &= (0, 1, 2, 3)\\
s_{job_0}(0)(3) &= (0, 1, 2, 3, 4)\\
s_{job_0}(0)(4) &= (0, 1, 2, 3, 4)\\
s_{job_1}(0)(0) &= (0) \\
s_{job_1}(0)(1) &= (0, 1) \\
s_{job_1}(0)(2) &= (0, 1, 2) \\
s_{job_1}(0)(3) &= (0, 1, 2, 3) \\
s_{job_1}(0)(4) &= (0, 1, 2, 3, 4) \\
s_{job_1}(1)(0) &= (0, 1, 2) \\
s_{job_1}(1)(1) &= (0, 1, 2, 3) \\
s_{job_1}(1)(2) &= (0, 1, 2, 3, 4) \\
s_{job_1}(1)(3) &= (0, 1, 2, 3, 4) \\
s_{job_1}(1)(4) &= (0, 1, 2, 3, 4) \\
\end{aligned}
$$

T=5でも列挙すると結構あるなあ。元の式を見ていく。

$$job_0$$は要素が1つなのでtermなし。
$$job_1$$は要素が$$(op_1, op_2)$$なので以下になる。( $$(len(ops)-1)-1$$よりループは1回 )

$$
	wx_{op_1T+0}x_{op_2T+0} + \\
	wx_{op_1T+1}x_{op_2T+0} + \\
	wx_{op_1T+1}x_{op_2T+1} + \\
	wx_{op_1T+2}x_{op_2T+0} + \\
	wx_{op_1T+2}x_{op_2T+1} + \\
	wx_{op_1T+2}x_{op_2T+2} + \\
	wx_{op_1T+3}x_{op_2T+0} + \\
	wx_{op_1T+3}x_{op_2T+1} + \\
	wx_{op_1T+3}x_{op_2T+2} + \\
	wx_{op_1T+3}x_{op_2T+3} + \\
	wx_{op_1T+4}x_{op_2T+0} + \\
	wx_{op_1T+4}x_{op_2T+1} + \\
	wx_{op_1T+4}x_{op_2T+2} + \\
	wx_{op_1T+4}x_{op_2T+3} + \\
	wx_{op_1T+4}x_{op_2T+4}
$$

op番号とTを展開すると以下になる。

$$
\begin{aligned}
& wx_5x_{10} + \\
& wx_6x_{10} + wx_6x_{11} + \\
& wx_7x_{10} + wx_7x_{11} + wx_7x_{12} + \\
& wx_8x_{10} + wx_8x_{11} + wx_8x_{12} + wx_8x_{13} + \\
& wx_9x_{10} + wx_9x_{11} + wx_9x_{12} + wx_9x_{13} + wx_9x_{14} + \\
& wx_{10}x_{10} + wx_7x_{11} + wx_7x_{12} + \\
\end{aligned}
$$

なんじゃこりゃ。どういうこっちゃねん。

たぶん結果となるx_iは縦opの数=3横T=5になるんだと思う。

|        |   $$t_0$$|   $$t_1$$|   $$t_2$$|   $$t_3$$|   $$t_4$$|
|:------:|:--------:|:--------:|:--------:|:--------:|:--------:|
|$$op_0$$|   $$x_0$$|   $$x_1$$|   $$x_2$$|   $$x_3$$|   $$x_4$$|
|$$op_1$$|   $$x_5$$|   $$x_6$$|   $$x_7$$|   $$x_8$$|   $$x_9$$|
|$$op_2$$|$$x_{10}$$|$$x_{11}$$|$$x_{12}$$|$$x_{13}$$|$$x_{14}$$|

こんな感じ。この表に照らし合わせてみると$$wx_5x_{10}$$は、$$t_0$$に$$op_1$$と$$op_2$$を実行させる、つまり$$x_5=1, x_{10}=1$$のときは重み$$w$$だけペナルティを与えるってことだと推測。

つまり、0が理想でcostが最小になるような最適化を走らせるわけだ。ふむふむ。

### operation_once_constraint
オペレーションの重複制約、重複したら1以上、1回だけなら0ってことだと思う。


> Penalty function is of form: 2xy - x - y + 1

ってのがよくわからん。いきなりy出てくるし。
多分このyも$$x_i$$なんでしょう。つまり

$$
	2x_ix_j - x_i - x_j + 1
$$

みたいな。

再度このマトリックスにご登場いただく。

|        |   $$t_0$$|   $$t_1$$|   $$t_2$$|   $$t_3$$|   $$t_4$$|
|:------:|:--------:|:--------:|:--------:|:--------:|:--------:|
|$$op_0$$|   $$x_0$$|   $$x_1$$|   $$x_2$$|   $$x_3$$|   $$x_4$$|
|$$op_1$$|   $$x_5$$|   $$x_6$$|   $$x_7$$|   $$x_8$$|   $$x_9$$|
|$$op_2$$|$$x_{10}$$|$$x_{11}$$|$$x_{12}$$|$$x_{13}$$|$$x_{14}$$|

$$x_0$$と$$x_1$$で考えてみると

$$
	f(x_0, x_1) = 2x_0x_1 - x_0 - x_1 + 1
$$

になって、$$(x_0, x_1) := (0,0) (0,1) (1,0) (1,1)$$を入れてみると

$$
	f(0,0) = 2\cdot0\cdot0 - 0 - 0 + 1 = 1 \\
	f(0,1) = 2\cdot0\cdot1 - 0 - 1 + 1 = 0 \\
	f(1,0) = 2\cdot1\cdot0 - 1 - 0 + 1 = 0 \\
	f(1,1) = 2\cdot1\cdot1 - 1 - 1 + 1 = 1
$$

なるほど排他的になるわけだ。つまり、重複制約をかけたい$$x_i$$の組み合わせ分こいつを用意してやるということか。

だから、$$x_0 ～ x_4$$の中で組み合わせ$${}_5\mathrm{C}_2$$、$$x_5～x_9$$で組み合わせ$${}_5\mathrm{C}_2$$、$$x_{10}～x_{14}$$で組み合わせ$${}_5\mathrm{C}_2$$を作ることになる。

制約は、各オペレーション内で書けなくてはいけないので$$f(x_0,x_5)$$のようにオペレーションをまたぐような組み合わせはない。

### no_overlap_constraint

かぶったらダメ制約。
それぞれのオペレーションには$$t_i$$だけかかるのでそれがかぶってもいけないし、オペレーションはそれぞれ実行できるマシンが決まってるのでマシンを使う時間がかぶってもいけない

$$
\sum_{ops \leftarrow machine} 
\sum_{i \leftarrow ops}
\sum_{k \leftarrow ops}
\sum_{t=0}^{T-1} \left\{ 
	wx_{iT+t}x_{kT+t} + 
	\sum_{s=t}^{min(t+t_{op_i},T)-1}wx_{iT+t}x_{kT+s}  + 
	\sum_{s=0}^{t-1} \left(
	\begin{cases}
		wx_{iT+t}x_{kT+s} & (i < k) \\
    		wx_{iT+s}x_{kT+t}  & (i > k)
	\end{cases}
	\right) where \exist op_i,op_k \in job
\right\} \ where\ i \ne k
$$

む、ムズイ!

マシンとオペレーションの関係は
$$
	machine_0 = (op_0, op_1) \\
	machine_1 = (op_2)
$$
こうだから、$$where i \ne k$$で考えると$$machine_0$$だけ考えればよくて、$$op_0$$と$$op_1$$は同じjobに属してないから

$$wx_{iT+t}x_{kT+t}$$と$$\sum_{s=t}^{min(t+t_{op_i},T)-1}wx_{iT+t}x_{kT+s} $$だけ考えればよさそう。

$$
	wx_{op_0T+0}x_{op_1T+0} + \\
	wx_{op_0T+0}x_{op_1T+0} + \\
	wx_{op_0T+0}x_{op_1T+1} + \\
	wx_{op_0T+1}x_{op_1T+1} + \\
	wx_{op_0T+1}x_{op_1T+1} + \\
	wx_{op_0T+1}x_{op_1T+2} + \\
	wx_{op_0T+2}x_{op_1T+2} + \\
	wx_{op_0T+2}x_{op_1T+2} + \\
	wx_{op_0T+2}x_{op_1T+3} + \\
	wx_{op_0T+3}x_{op_1T+3} + \\
	wx_{op_0T+3}x_{op_1T+3} + \\
	wx_{op_0T+3}x_{op_1T+4} + \\
	wx_{op_0T+4}x_{op_1T+4} + \\
	wx_{op_0T+4}x_{op_1T+4}
$$

なんか同じ式が出てきてるけどいいんだろうかこれ？

とりあえず$$op_i$$と$$T$$を展開する

$$
	wx_{0}x_{5} + \\
	wx_{0}x_{5} + \\
	wx_{0}x_{6} + \\
	wx_{1}x_{6} + \\
	wx_{1}x_{6} + \\
	wx_{1}x_{7} + \\
	wx_{2}x_{7} + \\
	wx_{2}x_{7} + \\
	wx_{2}x_{8} + \\
	wx_{3}x_{8} + \\
	wx_{3}x_{8} + \\
	wx_{3}x_{9} + \\
	wx_{4}x_{9} + \\
	wx_{4}x_{9} 
$$

またまたマトリックスの出番だ

|        |   $$t_0$$|   $$t_1$$|   $$t_2$$|   $$t_3$$|   $$t_4$$|
|:------:|:--------:|:--------:|:--------:|:--------:|:--------:|
|$$op_0$$|   $$x_0$$|   $$x_1$$|   $$x_2$$|   $$x_3$$|   $$x_4$$|
|$$op_1$$|   $$x_5$$|   $$x_6$$|   $$x_7$$|   $$x_8$$|   $$x_9$$|
|$$op_2$$|$$x_{10}$$|$$x_{11}$$|$$x_{12}$$|$$x_{13}$$|$$x_{14}$$|

$$x_0$$と$$x_5$$が両方とも1だとすると$$t_0$$で$$op_0$$と$$op_1$$が同じマシンを使おうとするのでだめということか.
$$x_0$$と$$x_6$$が両方とも1の時は、$$op_2$$の作業時間が2かかるのでかぶってしまうからダメ。よくできてるー。

## コスト関数
ペナルティをまとめるとこんな感じ。

$$
cost =
wx_5x_{10} +
wx_6x_{10} + wx_6x_{11} + 
wx_7x_{10} + wx_7x_{11} + wx_7x_{12} + \\
wx_8x_{10} + wx_8x_{11} + wx_8x_{12} + wx_8x_{13} +  \\
wx_9x_{10} + wx_9x_{11} + wx_9x_{12} + wx_9x_{13} + wx_9x_{14} + \\
wx_{10}x_{10} + wx_7x_{11} + wx_7x_{12} + \\
2x_0x_1 - x_0 - x_1 + 1 + 
2x_1x_2 - x_1 - x_2 + 1 + 
2x_2x_3 - x_2 - x_3 + 1 + \\
2x_3x_4 - x_3 - x_4 + 1 + 
2x_5x_6 - x_5 - x_6 + 1 + 
2x_6x_7 - x_6 - x_7 + 1 + \\
2x_7x_8 - x_7 - x_8 + 1 + 
2x_8x_9 - x_8 - x_9 + 1 + 
2x_{10}x_{11} - x_{10} - x_{11} + 1 + \\
2x_{11}x_{12} - x_{11} - x_{12} + 1 + 
2x_{12}x_{13} - x_{12} - x_{13} + 1 + 
2x_{13}x_{14} - x_{13} - x_{14} + 1 + \\
wx_{0}x_{5} + 
wx_{0}x_{5} + 
wx_{0}x_{6} + 
wx_{1}x_{6} + 
wx_{1}x_{6} + 
wx_{1}x_{7} + 
wx_{2}x_{7} + \\
wx_{2}x_{7} + 
wx_{2}x_{8} + 
wx_{3}x_{8} + 
wx_{3}x_{8} + 
wx_{3}x_{9} + 
wx_{4}x_{9} + 
wx_{4}x_{9} 
$$

costが最小になる$$x_0 ～ x_{14}$$見つければいい。Microsft QIOに投げると見つけてくれる